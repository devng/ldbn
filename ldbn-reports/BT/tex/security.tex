\chapter{Security Issues}
\label{chap:security}
In this chapter we discuss different security issues, such as authentication mechanisms for users and session management routines. 
In addition, we present different types of attacks that could be performed against our system, and what solutions we apply to prevent them.
Security also involves protecting the data, i.e., the scanned pages, from misuse. This is discussed in Section~\ref{sec:dataprotection} and~\ref{sec:screenshots}.

\section{User Authentication and Session Management}
\label{sec:authentication}
In this section we provide a more formal description of the authentication mechanisms
involved in our system. First, we should point out that we use session-based authentication for both clients. This means that
user credentials are sent over the network only the first time the user logs-in to the server, and not each time a request is posted. After a successful log-in, a unique session ID is generated for each user. It is saved on the server and sent
back to the client. All further requests include the session ID, which is used to distinguish between users and 
save their state information on the server. 
In general, session-based authentication offers greater control over user interactions with the server. 
However, when dealing with session IDs there a number of issues that need to be considered. We describe these in this section. 
The most common attacks to session-based authentication system are:

\begin{itemize}
%	\item \textbf{Session hijacking} is when an attacker takes control of a user session and uses the session ID to legitimate himself
%	as another user~\cite[p. 60]{bookwebsec}. 
	\item \textbf{Session hijacking} is when an attacker masquerades himself as another legitimate user 
	by using that person's session ID~\cite[p. 60]{bookwebsec}. 
	\item \textbf{Session fixation} occurs when the session ID is stolen before a legitimate user ever 
	gets it. An attacker could force another user to use a known session ID value when logging in,
	allowing the attacker to compromise the session later on~\cite[p.~61]{bookwebsec}. Figure~\ref{fig:session-fixation} 
	demonstrates this, which is an adaptation of~\cite[Figure 4-17]{bookwebsec}. A complete survey of the attack
	can be found in~\cite{wsessionfix}.  
\end{itemize}

\begin{figure}[htp]
	\begin{center}
		\includegraphics[width=0.85\textwidth]{./img/session-fixation}
		\caption{Example of Session Fixation}
		\label{fig:session-fixation}
	\end{center}
\end{figure}

In the following two sections we describe how the different clients, i.e., the ELBS viewer and the 
download portal, authenticate users and deal with the attacks, described above. 

\subsection{ELBS Viewer}
When it comes to the ELBS Viewer, there are two different types of authentication:

\begin{enumerate}
	\item Authentication of the client's computer~- the provided session ID is used only for viewing pages.
	\item Authentication of the user~- the provided session ID is only used for printing/downloading pages as PDF. 
\end{enumerate}


The first type of authentication is necessary, because the ELBS viewer is only allowed to run on certain computers
in a reading room at the University Library of Würzburg. Computers in this room are identified based on 
their IP addresses\footnote{In ELBS we rely on IP Version 4.} and optional hard disk serial number. These informations are stored
in the database, as it was mentioned earlier in Section~\ref{sec:datapersistance}. The exact authentication mechanism is 
illustrated in Figure~\ref{fig:elbs-auth}, which is a simplified sequence diagram of all the HTTP requests and responses
involved. As the diagram shows, the first thing the client requests from the server is a random number (RN). This number 
is used throughout the entire session for different tasks, such as hashing the hard disk serial number (HDSN) and encrypting/decrypting pages. The server, on the other hand,
always checks if the client's IP address is present in the database. In the next step the client computes a hash value
of the HDNR and the RN. The value is then sent to the server, which also makes the same computation and compares the two hash values. If they are the same, the server generates a random session ID, saves it in the database and sends it back to the client.  Note that each session ID is associated with an IP address and a timestamp value. The latter is updated after each interaction. The whole process of hashing the HDSN together with the RN ensures that the actual HDNR is never sent over the network. However, Windows does not always allow computer programs to read the HDSN, therefore this step is optional and can be disabled from the configuration of the server. 
In the next step, the client asks for some meta information about 
the book, such as title, number of pages, bookmarks, etc. Finally, the client receives an encrypted page (image file) from the server, decrypts it and presents it to the user.  
We should point out that the authentication mechanism, described above, was used in ELBS 1.0 as well. However, it was improved in ELBS 1.1 by
the fact that parts of the image file are encrypted with the help of the RN, which ensures that only one client can decode and view the received page. In contrast, ELBS 1.0 uses the same encryption key for all image files. The exact encrypted image file format is described in Section~\ref{sec:dataprotection}.

\begin{figure}[h]
	\begin{center}
		\includegraphics[width=0.9\textwidth]{./img/elbs-client-auth.pdf}
		\caption{Client's Computer Authentication in ELBS}
		\label{fig:sequence-spring}
	\end{center}
\end{figure} 

The second type of authentication is the user authentication. As we mention in Section~\ref{sec:elbsviewer}, users need to log-in in order to print/save pages. They can use either their university account or one with credentials stored in our database. The latter can be created
by administrators with the help of the download portal. Figure~\ref{fig:elbs-auth} illustrates a diagram of the authentication process. 
As can be seen, the user sends his user name and password along with a valid \emph{viewSessionID}, which refers to 
the session ID, described earlier in this section. Thus users can only authenticate themselves from computers which are allowed to run the ELBS viewer. On the server-side a series of checks is performed. The first one is to see if the provided \emph{viewSessionID} is valid. A valid session means that, among other things, it has not expired, i.e., the user has had an interaction with the server in the last 15 minutes. In addition, since each \emph{viewSessionID} is associated with an IP address as well, the server has to assure that the request's IP address matches the one of the session, stored in the database. After the session has been validated, we check the provided credentials. First, a request with the provided user name and password is sent to the LDAP server of the university. Note that the LDAP server can only respond if the credentials of the user
are valid or not. Other information, such as user privileges, cannot be obtained from that server, 
which was also one of the reasons why our system has to manage these 
internally. If the LDAP server sends a positive response, i.e., the user name and password are valid,  a new entry is inserted in the 
\verb=user= table in our database. However, this is done only the first time a user logs into our system, in order to ensure that 
he has a unique user ID.  The latter is used to associate the user with the appropriate user rights/privileges, which is also done upon the
first successful log-in. 
In the case that the LDAP server sends a negative response, our server tries to verify the user name and password against the information stored in the \verb=external_user= table in our database.
After a successful validation of the user's credentials, a unique session ID is generated. It is called \emph{donwloadSessionID} and is used whenever a user is trying to print pages or download them as PDF. Finally, the client this ID along with the 
privileges of the user. 
It should be noted that privileges are checked both on the client- and server-side. The client-side check is used as a preemptive measure, in order to prevent unnecessary load, because in the cases that the privileges are not allowing the user to print/download some content, no further requests are sent to the server. This approach also makes the program more responsive to the user's input, when he is denied access to a document.   

\begin{figure}[h]
	\begin{center}
		\includegraphics[width=0.9\textwidth]{./img/elbs-auth.pdf}
		\caption{User Authentication in ELBS 1.1}
		\label{fig:elbs-auth}
	\end{center}
\end{figure}

In relation to the two types of session attacks, described earlier,
 we can say that the authentication mechanisms, we use in ELBS 1.1, are not vulnerable to \emph{session fixation}. The reason for that is the fact that our server issues a new session ID for each new generated session. Moreover, the viewer cannot be forced to use an attacker-chosen ID. We also take a number of measurements to prevent \emph{session hijacking}. 
The first thing that our system needs to focus on, is the generation
of the session IDs. A session ID needs to be unpredictable, otherwise it is trivial to hijack another 
user's session~\cite[p. 62]{bookwebsec}. To overcome this issue we use the \verb=java.security.SecureRandom= class, which provides a cryptographically strong pseudo-random number generator~\cite{wsecrandom}. 
Second, all sessions in ELBS have a timestamp value associated with them, which is updated with each client interaction.
If no one has used the session for a period of time, usually 15 minutes, the session expires. This prevents attackers from using old, inactive sessions, in case that the user does not log-out properly.
The third main security measure is connected with the IP-binding of each session, meaning that
a session is only valid on a particular computer and attackers cannot use it elsewhere. 
Finally, in order for the IDs not to be
easily captured over the network, where an attacker may be listening, data between server and client is sent only over HTTPS.   

\subsection{Download Portal}
Compared to the ELBS viewer, the download portal (DP) uses a different approach for authentication and session management. 
It utilizes an extension of the Spring library, called Spring Security, which is 
a powerful and highly customizable authentication and access-control framework. It is the de-facto standard for securing Spring-based applications~\cite{wspringsec-2}. Figure~\ref{fig:sc-filters} illustrates the way Spring Security works. 
The basic idea is that it installs a number of servlet filters in a specific order (chain) between the client and the Spring Dispatcher Servlet, 
which was described in Section~\ref{sec:sysarch}. The result is that client's requests are forced to go through the chain of filters
before reaching our application. The job of the filters is to secure specific URLs, that needs to be accessed only by authorized users.
The way filters in Spring Security work is better understood with the help of an example. 
Let us assume that an anonymous user is trying to access a secured HTML link, such as a link to a downloadable document in the download portal. Upon request, a filter in the chain detects that the user is not authenticated, based on his session ID. This causes the filter to 
store the entire HTTP request in the server's response and redirects the user to a log-in page. After the user has successfully logged in, the filter passes the initial request to the dispatcher servlet, which on the other hand redirects the request to the appropriate controller. At this point the controller can be sure that the request comes from an authenticated user. 
The entire authentication process 
is done by Spring Security. In order to perform additional security checks, session information, such as user name, can be accessed by the controller via the \verb=SecurityContextHolder= class. 


\begin{figure}[h]
	\begin{center}
		\includegraphics[width=0.75\textwidth]{./img/sc-filters.pdf}
		\caption{Spring Security Filter Chain}
		\label{fig:sc-filters}
	\end{center}
\end{figure}

Incorporating Spring security in the download portal is a matter of making the corresponding changes in the \verb=web.xml= configuration file on the Web server. We do not have to implement any filters, because the existing ones can be easily configured with the help of an separate
XML file. The latter is used to specify which links of our application need to be secured, and which privileges must a user have in order to access them. We only need to implement a custom class for the \verb=AuthenticationProvider= interface. This class is used by Spring Security
to validate user's credentials with the help the LDAP server of the university, or with with the help of our database. 
The process of validation is similar to the one of the ELBS viewer, which was described in the previous section.  
Furthermore, the class is responsible for loading the corresponding privileges from the database and storing them in an \verb=AuthenticationToken= object, which is required by different components of Spring Security, e.g., the servlet filters.

%TODO
%It should be noted  that in our implementation it is the job of the controller to apply further restriction to resources, such as downloadable documents. 
%The reason for that is the fact that Spring Security uses the Role Based Access Control (RBAC) model and, as we mentioned earlier in Section~\ref{}, restrictions change dynamically. 

At this point, the reader might have noticed that we do not have any database tables for storing session information about the download portal. The reason for that is the fact that, 
in contrast to the ELBS viewer, we do not implement any session management routines for the download portal, because these are all handled by Spring Security. Thus, Spring Security is responsible for generating session IDs, sending them back to the clients, and validating them. Furthermore, session IDs are not stored in a database, but rather in the server memory.

In relation to the two types of session attacks described earlier, Spring Security protects against \emph{session fixation} automatically by creating a new session when a user logs in~\cite[Section 2.3.3]{wspringsec-1}. To minimize the risk of \emph{session hijacking}, we apply similar techniques to the ones described in the previous section. This means that we configured Spring Security to invalidate inactive sessions after 15 minutes. In addition, session cookies are sent only over HTTPS and only one active session is allowed per user.
However, because of the fact that the download portal is a Web-based application that runs within a browser, we need to prevent Cross-site scripting (XSS) attacks as well. These attacks can also be used for \emph{session hijacking}. XSS refers to a technique, where an attacker enters a script into the URL or form fields of vulnerable sites. The input is then often offered to some other users of the Web-application, and the script is executed in their Web browser. Because HTML scripts are embedded using the \verb=<script>= tag, an easy and efficient way to prevent such attacks, is to escape HTML special characters, such as \lt~and~\gt.  
 
\section{Data Protection}
\label{sec:dataprotection}
In this section we describe the different techniques that we apply to prevent users form obtaining illegal copies of book pages.

\subsection{File Encryption} 
Book pages in ELBS are encrypted scanned images. Encrypting the files ensures that E-Book pages can only be viewed with
our program. 
In ELBS 1.0 the implemented encryption algorithm was Block Tiny Encryption Algorithm~\cite{wtea-1}. However, in~\cite{cryptoeprint:2010:254} it was shown that the algorithm does not provide the intended
128-bit security. Moreover, in ELBS 1.0 we used the same key for all pages. To deal with these issues,
a more secure and flexible format was needed. Figure~\ref{fig:cimg-format} illustrates the new file format we use in ELBS 1.1. Note that it is not bound to any particular encryption algorithm.
The default encryption is done using  AES-128 (Advanced Encryption Standard\cite{waes-1}), but we also support other popular algorithms, such as
AES-192, AES-256, Blowfish and Twofish, by utilizing the Botan cryptographic library~\cite{wbotan}.
Based on the \emph{File Version} number, the client can choose the decryption method for a particular file. It is not even required for all pages of a book to use the same encryption.
 
In the current version of the format
each page is encrypted with a different key, which is randomly generated with the creation of the file and stored in it. However, upon sending the file to the client, we encrypt this original file key ($K_1$) with an additional key ($K_2$). The latter is only known to the server and the client, ensuring that other clients or attackers cannot decrypt the image. The way we transmit $K_2$ to the client is by using a random number ($RN$), which is sent only once for the entire session, using HTTPS. To compute $K_2$, the $RN$ is hashed with a secret hash function, which is only known to the ELBS viewer and the server. Furthermore, the hash function is compiled with the source code of the programs, thus it is never sent over the network. The actual output of the function for the $RN$ is used as $K_2$. $K_2$ is then used to decrypt $K_1$. On the other hand, $K_1$ is utilized for the decryption of the actual image file. The whole process ensures that $K_2$ is never sent over the network.

Keeping the key in the file could be seen as a potential risk. However, the only place where that key is not encrypted is on the server-side, which is considered to be a trusted environment. If it is required, we can easily overcome this issues by encrypting each file key with a master key, which only the server should know. Note that keeping the key in the file has advantages as well. First, all relative data is encapsulated in a single file, and we are never faced with the threat of loosing the encryption keys. In such a case, the encrypted images would become unusable. Second, we can offer users a faster server response, because, upon request, we only have to encrypt a small portion of the file.

Another improvement over the old format is the fact that the new one can support different image formats. Based on information provided by the \emph{Image Format (IF)} file tag, the viewer can now switch between different formats. 

It should be noted that in order to deceive a potential attacker, we also include some random data in the file. This data is then ignored by the viewer. 

Last but not least, with the help of the file header ELBS 1.1 can distinguish between the two different formats. This means that and the viewer is still able to utilize the old encrypted files of ELBS 1.0. 

\begin{figure}[htb]
	\begin{center}
		\includegraphics[width=0.75\textwidth]{./img/cimg-format.pdf}
		\caption{Encrypted Image Format in ELBS 1.1}
		\label{fig:cimg-format}
	\end{center}
\end{figure} 

\subsection{Preventing Illegal Distribution of Pages}
\label{sec:IllegalDistribution}
As we described earlier, in ELBS 1.1 we allow user to print pages or to save them as PDF files. In these cases, we always add
a watermark with the name of the user to each page. This way if a book is leaked to the public we can trace the user that was, most likely, responsible for it.
An example of a watermark on a page is presented in Figure~\ref{fig:watermark}.  

In Section~\ref{sec:elbsviewer} we mentioned that the option to save pages as PDF files can be disabled form the server. In this case, however, we must also ensure that the user is not allowed to use PDF printers, with the help of which he can easily overcome this obstacle and produce PDF files.
To achieve this task we control the whole process of printing and do not depend on external programs. In ELBS the user can only select a printer
from a predefined list of printers, which is sent by the server. The selection is done with the help of the \emph{Select Printer} dialog, shown in Figure~\ref{fig:printer-choise}.     

\begin{figure}[h]
	\begin{center}
		\includegraphics[width=0.55\textwidth]{./img/printer-choise}
		\caption{Select Printer Dialog}
		\label{fig:printer-choise}
	\end{center}
\end{figure} 

\section{Preventing Screenshots in ELBS Viewer}
\label{sec:screenshots}
Another important aspect of the viewer is its ability to prevent users from making screenshots, 
otherwise users can easily copy the content of a book. This feature was implemented in ELBS 1.0, but it was further improved in ELBS 1.1.  
In this section we present the advantages and disadvantages of the original approach, 
the current approach and outline a possible future approach for preventing screenshots. 

Early in the development of ELBS 1.0 it 
became apparent that preventing screenshots is essential part of the program. 
One possible technique for accomplishing this task, is the deactivation of the 
\verb=Print Screen= key on the keyboard. 
Indeed, it is possible to achieve this by making a corresponding entry in the Windows registry. 
However, this approach is neither sufficient, nor appropriate, as will be seen in the following reasoning.
First, it can easily be overcome with any screen capture program, 
since only the key on the keyboard is disabled but not the corresponding 
Win32 API functions, such as \verb=CreateDC=. With the help of the \verb=CreateDC= function, one can create 
a device context (DC), which  provides a "snapshot" of the screen contents.
An example of such a program is shown in Listing~\ref{listing:srcshot}. 
Second, globally disabling the
\verb=Print Screen= key should be avoided, as it disables the key even if 
ELBS is not running, thus could be irritating for the user. 
In order to prevent screenshots in ELBS 1.0 and ELBS 1.1 we apply a different and more 
sophisticated approach, which involves the use of an overlay surface.
The following section explains the concept of overlay surfaces in greater detail. 

\subsection{Overlay Surface}
This section is, for the most part, a summary of~\cite{wos1}.

Overlay surfaces are surfaces on the computer screen with special hardware-supported capabilities. 
Overlay surfaces are frequently used, for example to display video or still images over the primary surface, without changing the content of the primary surface. In our implementation we use an overlay surface to display pages of a book. 

Furthermore, overlay surface support is provided entirely by the hardware. DirectDraw supports any capabilities, as reported by the display device's driver. DirectDraw cannot emulate overlay surfaces. Therefore, in order the ELBS viewer to function correctly we require a display adapter (also known as graphics card or video card) with an overlay surface support. It should be mentioned that almost all of the DirectX-capable display adapters support this feature. 

An overlay surface is analogous to a clear piece of plastic that is drawn on and placed in front of the monitor. 
When the overlay is active, it literally overlays the contents of the primary screen surface, leaving it unchanged upon its removal.
In order to achieve this, while the display device paints scan lines to the monitor, it checks the location of each pixel in the primary surface to see if an overlay should be visible there instead. 
If this is the case, the graphics card displays the pixel values from the overlay surface, as shown in Figure~\ref{fig:overlaySurface}, which is an adaptation of~\cite[Figure 1]{wos1}.

\begin{figure}[ht]
	\begin{center}
		\includegraphics[width=0.82\textwidth]{./img/Figure_Overlays_BW.pdf}
		\caption{Overlay Surface}
		\label{fig:overlaySurface}
	\end{center}
\end{figure}  

By using this method, the display adapter produces a composite of the primary surface and the overlay on the display, without modifying the contents of either surface. 
The composite surface is injected into the video stream and sent directly to the monitor. 
Because this on-the-fly processing and pixel substitution is handled at the hardware level, 
no noticeable performance loss occurs when displaying overlays.

One can create overlay surfaces with the help of the \verb=IDirectDraw::CreateSurface= method. 
However, it should be noted that, overlay surfaces can only be created in video memory. 
As a result, programs that make screenshots and rely on Win32 API functions, 
such as the \verb=CreateDC= function,
only copy the content of the primary surface and not the content of the overlay surface.
In ELBS Viewer we use this side effect of the overlay surfaces, 
in order to create an overlay surface for the pages of a book. 
Thus, users cannot make screenshots via the trivial way with the \verb=Print Screen= key or 
with the help of non-overlay-capable screen capture software. 
However, there is a small number of screen capture programs such as FRAPS~\cite{wfraps} 
that can access the video memory directly, and do not rely on 
Win32 API functions for screen capturing. As a result, 
such programs are capable of making a screenshot of the content of the overlay surface.  
Therefore, it is important to detect the use of such software while the ELBS viewer is running. 
How this is achieved is discussed in the following section.  

\subsection{Detecting a Running Processes in Windows}
\label{sec:procdetection}
As mentioned in the previous section, it is important for our implementation to be able to detect certain processes, such as FRAPS, which could compromise the secure use of the ELBS viewer. In this section we discuss how the ELBS 1.0 detected such processes and what improvements we make to the current version of the viewer~- ELBS 1.1. In addition, we present some of the software problems that lie within the detection of a running processes in Windows.

In the following the term blacklist processes is used to refer to processes
which we try to detect. This is so, because we store metadata
about those processes in a so called black list.

In ELBS 1.0 we use the \verb=Process32Next= function, which is part of the Win32 API. With its help it is possible to get the names of all running processes. However, the function does not give the path to the EXE files of any of them. Therefore, in ELBS 1.0 we detect whether a process is running, simply by comparing its name to a blacklist of names.  We perform this check every two seconds. Upon a detection of a malicious process, we present the user with an error message, as the one shown in Figure~\ref{fig:error2001}, and delete the overlay surface, freeing the video memory, thus preventing screenshots of any kind. However, this method of detecting a running process is not very secure, as one can easily rename the EXE file and ELBS 1.0 would not be able to identify the blacklist process. Although  it is unlikely  for an average user to perform such an operation, it is clear that we need a better approach for ELBS 1.1.

\begin{figure}[ht]
	\begin{center}
		\includegraphics[width=0.6\textwidth]{./img/error2001.png}
		\caption{Error Message upon Detection of FRAPS}
		\label{fig:error2001}
	\end{center}
\end{figure} 

An initial idea for performing a blacklist process check was to obtain the path of a running process and to analyze the EXE file. Indeed, it is possible to obtain the file path of a running process with the help of the following two Win32 API functions:  \verb=CreateToolhelp32Snapshot= and \verb=Module32First=. 
However, there are two major disadvantages with this approach. First, the \verb=CreateToolhelp32Snapshot= function can only be called by an administrative user in Windows, otherwise it returns an error with the following message: \emph{WARNING: CreateToolhelp32Snapshot (of modules) failed with error 5 (Access is denied)}. Second, performing a simple file analysis of the EXE file, such as computing its checksum and comparing it to a blacklist of checksums, is insufficient.  The reason for that is the fact that one can easily change the checksum of an EXE file with a simple text editor, e.g. by adding a single whitespace character at the end of the file. This changes the checksum of the EXE file, but the file is still a valid executable. Thus, computing a checksum of a file and comparing it to a blacklist of checksums is not more secure than comparing a filename to a blacklist of names. In the process of development of ELBS 1.1 it became apparent that in order for this new approach for detecting a blacklist process to work, we have to develop a separate application in a similar fashion as an anti-virus program. This implies that the application should be developed as a separate service that starts at system startup and runs in the administrative user space, ensuring that the \verb=CreateToolhelp32Snapshot= function does not return an error. In addition, the service has to be able to communicate with the ELBS viewer, so that the viewer is able to delete the overlay surface upon a detection. On the one hand, the new service must do extensive file analysis. 
This could involve hashing only certain parts of the file, ensuring that a user cannot easily manipulate the hash value. On the other hand, the service must prevent the generation of too many false-positive detections of common Windows applications. 
Implementing such a service is, indeed, overly-complicated and it is beyond the scope of this diploma thesis and therefore it is omitted.

In ELBS 1.1 we use another approach of detecting a running process. In Windows every GUI-application has a top-level window associated with it. With the help of the \verb=FindWindow= and \verb=EnumWindows= Win32 API functions it is possible to determine if an application is running, based on the name of its top-level window. The \verb=FindWindow=  function finds a top-level only if we pass the exact name of the windows as an argument. This might become ineffective, as many applications tend to change the name of the window during execution time or include a version number in the name. Therefore, ELBS might not be able to detect the running application if we only rely on the \verb=FindWindow= function. A better approach is to use the \verb=EnumWindows= function, with the help of which one could enumerate the top level windows of all the running applications, even the ones that are not currently visible. This way we can analyze the name of the window by searching for a substring in the name, or try to match the name against a regular expression. Another major benefit of this approach is the fact that those functions do not need an administrative user rights, in order to be called. In addition, it is very hard for a user to change the name of the top-level window, without recompiling the application. We believe that this approach is secure enough for our purposes. At this point it should be noted that all of the applications we want to prevent from executing are, indeed, GUI-applications, and have a top-level window associated with them. 

This approach has some drawbacks as well. The biggest of which is the fact that it could generate false-positives, since a substring or a regular expression from the blacklist could match the name of another application's top-level window, and not the ones we are trying to block. The following example illustrates a scenario how a false-positive could be generated. Windows Explorer changes the name of its top-level window depending on the name of the directory which is currently opened. If we have a string \emph{FRAPS} in the blacklist and a user has opened a directory with the name \emph{FRAPS}, then our program produces a false-positive detection. In our opinion, however, this is a very rare case, as most of the applications, which we are trying to detect, have
very uncommon top-level window names.  
